[{"categories":["kotlin"],"content":" Kotlin Object 코틀린에는 static 키워드가 없기 때문에 object 키워드를 활용하여 static을 대체할 수 있어야 함.\n코틀린에서는 object로 static키워드를 바이트코드 변환시 best practice적인 방법으로 제공해줌 (Java로 디컴파일러 해보면 의도를 알 수 있음)\n object 키워드는 static이 아닙니다\n  Overview  싱글턴 class 만들기 static 메소드 만들기 companion object 익명객체 만들기   싱글턴 class 만들기 아래 코드는 학생들의 평균 점수를 구하는 메소드를 구현한 싱글턴 클래스 입니다.\nobject객체는 Java코드로 디컴파일시 class로 변환되므로 extends, implements를 구현할 수 있습니다.\n1 2 3 4 5 6 7 8 9  object StudentManager { val students = arrayListOf() fun calculateAvg(): Unit { for (student in students) { ... } } }   object 키워드로 생성된 object에 접근하려면 object의 ‘이름.요소’로 접근하면 됩니다.\n1 2  StudentManager.students.add(...); StudentManager.calculateAvg();    static 메소드 만들기 companion object static을 사용할 수 없는 대신 companion object로 top-level function을 만들 수 있습니다.\n companion object는 private 맴버에는 접근 할 수 없습니다.\n 1 2 3 4 5 6 7  class Foo { companion object { fun bar(): Unit { ... } } }   아래와 같이 호출 가능\n1  Foo.bar();   companion object에 이름도 정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  class Foo { companion object Name { fun bar(): Unit { ... } } } // 둘 다 호출 가능 Foo.Name.bar(); Foo.bar();    익명객체 만들기 클릭 리스너가 onClick이벤트를 발생하였을 때 익명으로 생성 된 function이 실행되는 것을 확인할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  interface ClickListener { fun onClick() } fun main(args: Array) { setClickAction(object: ClickListener { override fun onClick() { ... } }) } fun setClickAction(clickListener: ClickListener) { clickListener.onClick() }   ","description":"","tags":["kotlin","kotlin object","keyword","코틀린"],"title":"[Kotlin] Object 키워드 활용하기","uri":"/posts/kotlin/kotlin-object-keyword/"},{"categories":["c-sharp"],"content":" Call by Reference와 Call By Value C#에서 메소드를 호출할 때 파라미터 값을 넘겨야 할 때가 있습니다.\n메소드가 실행 될 때 값을 그대로 복사하여 메소드 종료 이후 stack상에서 사라지는 파라미터를 call by value, 복사가 아닌 메모리 주소가 넘겨지는 방식을 call by reference라고 합니다.\n C언어의 포인터가 call by reference라고 보시면 이해하기 훨씬 쉽습니다.\n  Overview  C#에서의 Call By Value C#에서의 Call By Reference 만약 ref키워드가 없는 자바같은 언어라면?   C#에서의 Call By Value Swap 메소드는 파라미터 a와 b의 값을 바꾸어 주는 역할을 하는 것 처럼 보입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static void Main (string[] args) { int a = 10, b = 20; Console.WriteLine(\"Swap메소드를 실행하기 전 : a = \" + a + \", b = \" + b); Swap(a, b); Console.WriteLine(\"Swap메소드를 실행한 뒤 : a = \" + a + \", b = \" + b); } static void Swap (int a, int b) { int temp; temp = a; a = b; b = temp; }   위의 코드의 output\n1 2  Swap메소드를 실행하기 전 : a = 10, b = 20 Swap메소드를 실행한 뒤 : a = 10, b = 20   결과를 보면 알 수 있드시 파라미터로 넘어간 값의 주소와 실제 메소드에서 사용한 메모리의 주소가 다르다는 것을 유추 할 수 있습니다.\n C#에서의 Call By Reference 위와 비슷한 소스코드 처럼 보이지만 메소드의 파라미터 자료형 앞에 ref키워드가 붙은 것을 확인 할 수 있습니다.\nstatic void Main (string[] args) { int a = 10, b = 20; Console.WriteLine(\"Swap메소드를 실행하기 전 : a = \" + a + \", b = \" + b); Swap(ref a, ref b); Console.WriteLine(\"Swap메소드를 실행한 뒤 : a = \" + a + \", b = \" + b); } static void Swap (ref int a, ref int b) { int temp; temp = a; a = b; b = temp; } 위의 코드의 output\nSwap메소드를 실행하기 전 : a = 10, b = 20 Swap메소드를 실행한 뒤 : a = 20, b = 10 위와 같이 ref키워드를 파라미터에 적어주면 변수의 값이 아닌 메모리 주소가 보내지는 것을 확인 할 수 있습니다.\n 만약 ref키워드가 없는 자바같은 언어라면? C#은 ref키워드로 파라미터의 메모리 주소를 넘겨주고, 메모리 주소를 메소드안에서 변경하는 것 까지 가능했습니다.\n그러나 ref키워드가 없는 Java, Javascript같은 언어에서는 primitive type은 무조건 call by value로 파라미터가 넘겨지고 reference type은 복사가 아닌 메모리주소가 파라미터로 넘겨집니다.\n단, C#의 ref키워드 처럼 메모리 주소를 변경하는 것 까진 불가능 하고 reference의 하위 필드들의 값을 변경하는 것은 가능합니다. (C#도 ref, out키워드를 사용하지 않으면 똑같은 성격임)\n","description":"","tags":["C#","call by reference"],"title":"[C#] Call By Reference","uri":"/posts/c-sharp/call-by-reference/"},{"categories":["javascript"],"content":" 꼬리 물기 최적화 (Tail Call Optimization) 함수 안에서 함수를 호출하면 호출이 된 함수에서 호출을 한 함수로 돌아오는 반환 지점을 가지고 있어야 한다.\nTail Call Optimization는 호출을 한 함수로 돌아오지 않아도 되도록 함수 설계하여 call stack메모리를 계속 재활용 할 수 있도록 하는 것 이다.\n 최종적으로, 마지막 호출이 된 함수가 최초로 호출 된 함수로 반환\n  조건  맨 마지막 구문에서 함수를 실행해야 함 언어 스팩상 호출을 한 함수의 stack에 메모리를 쌓지 않는 연산자는 사용 가능함   Tail Recursion 피보나치 수열 구하기 정확히 100번의 재귀호출로 피보나치 수열을 구하는 함수이다\n1 2 3 4 5 6 7  function fibonacci(n, prevFibo = 1, prevPrevFibo = 0) { if (n \u003c 2) { return prevFibo; } return fibonacci(n - 1, prevFibo + prevPrevFibo, prevFibo); }   5번 째의 피보나치 수열을 구해보자\n1 2  fibonacci(5); // 5    함수는 내부적으로 아래와 같이 동작되어 값을 반환할 것이다\ncall fibonacci(5) 파라미터 값을 (4, 1, 1)로 변경 파라미터 값을 (3, 2, 1)로 변경 파라미터 값을 (2, 3, 2)로 변경 파라미터 값을 (1, 5, 3)로 변경 return 5 즉, 리턴은 재귀의 맨 마지막 호출일 경우에만 하므로, call stack을 최적화 시킬 수 있다\n 언어 정리  Tail Recursion: Tail Call을 재귀함수로 사용할 때 Tail Recursion라고 함   기타 참고사항  Javascript의 언어 스팩상 삼항 연산자는 call stack에 메모리를 생성하지 않음 후위 증감 연산자는 call stack에 메모리를 생성함 브라우저별 tail call optimization 지원 현황을 확인하려면 여기{:target=\"_blank\"}{:class=“a-tag-link”}를 클릭하세요 2020/06/24일 기준 tail call optimization을 지원하는 브라우저는 사파리밖에 없음  참고  https://homoefficio.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/{:target=\"_blank\"} https://velog.io/@yesdoing/%EA%BC%AC%EB%A6%AC-%EB%AC%BC%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94Tail-Call-Optimization%EB%9E%80-2yjnslo7sr#-%EA%B7%B8%EB%9F%BC-%EC%99%9C-%EA%BC%AC%EB%A6%AC-%EB%AC%BC%EA%B8%B0-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC–%ED%95%A0%EA%B9%8C%EC%9A%94{:target=\"_blank\"}  ","description":"","tags":["javascript","js","tail call optimization","꼬리물기 최적화"],"title":"[javascript] 꼬리 물기 최적화 (Tail Call Optimization)","uri":"/posts/javascript/tail-call-optimization/"}]
