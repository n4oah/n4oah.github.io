<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on n4oah 개발 블로그</title>
    <link>https://n4oah.github.io/posts/</link>
    <description>Recent content in Posts on n4oah 개발 블로그</description>
    <image>
      <title>n4oah 개발 블로그</title>
      <url>https://n4oah.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://n4oah.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 12 Jul 2023 23:55:16 +0900</lastBuildDate><atom:link href="https://n4oah.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Reactor] Cold Sequence와 Hot Sequence</title>
      <link>https://n4oah.github.io/posts/spring/reactor-cold-hot-seq/</link>
      <pubDate>Wed, 12 Jul 2023 23:55:16 +0900</pubDate>
      
      <guid>https://n4oah.github.io/posts/spring/reactor-cold-hot-seq/</guid>
      <description>Cold와 Hot의 의미 https://reactivex.io/ “Hot” and “Cold” Observables에 대해 아래와 같이 설명되어 있다.
언제 Observable이 항목 시퀀스를 방출하기 시작합니까? Observable에 따라 다릅니다. &amp;ldquo;Hot&amp;rdquo; Observable은 생성되자마자 항목을 방출하기 시작할 수 있으므로 나중에 해당 Observable에 구독하는 모든 관찰자는 시퀀스의 중간 어딘가에서 관찰을 시작할 수 있습니다. 반면에 &amp;ldquo;Cold&amp;rdquo; Observable은 관찰자가 구독하기 전까지 항목을 방출하기를 기다리므로 이러한 관찰자는 시작부터 전체 시퀀스를 볼 수 있다는 것이 보장됩니다.
즉, Hot은 생성됨가 동시에 데이터를 방출하고, 나중에 구독한 구독자는 구독시점부터의 데이터를 받게된다.</description>
    </item>
    
    <item>
      <title>[Kotlin] Object 키워드 활용하기</title>
      <link>https://n4oah.github.io/posts/kotlin/kotlin-object-keyword/</link>
      <pubDate>Fri, 08 Jan 2021 10:53:16 +0900</pubDate>
      
      <guid>https://n4oah.github.io/posts/kotlin/kotlin-object-keyword/</guid>
      <description>Kotlin Object 코틀린에는 static 키워드가 없기 때문에 object 키워드를 활용하여 static을 대체할 수 있어야 함.
코틀린에서는 object로 static키워드를 바이트코드 변환시 best practice적인 방법으로 제공해줌 (Java로 디컴파일러 해보면 의도를 알 수 있음)
 object 키워드는 static이 아닙니다
  Overview  Kotlin Object  Overview 싱글턴 class 만들기 static 메소드 만들기 companion object 익명객체 만들기     싱글턴 class 만들기 아래 코드는 학생들의 평균 점수를 구하는 메소드를 구현한 싱글턴 클래스 입니다.</description>
    </item>
    
    <item>
      <title>[C#] Call By Reference</title>
      <link>https://n4oah.github.io/posts/c-sharp/call-by-reference/</link>
      <pubDate>Wed, 24 Jun 2020 10:53:16 +0900</pubDate>
      
      <guid>https://n4oah.github.io/posts/c-sharp/call-by-reference/</guid>
      <description>Call by Reference와 Call By Value C#에서 메소드를 호출할 때 파라미터 값을 넘겨야 할 때가 있습니다.
메소드가 실행 될 때 값을 그대로 복사하여 메소드 종료 이후 stack상에서 사라지는 파라미터를 call by value, 복사가 아닌 메모리 주소가 넘겨지는 방식을 call by reference라고 합니다.
 C언어의 포인터가 call by reference라고 보시면 이해하기 훨씬 쉽습니다.
  Overview  Call by Reference와 Call By Value Overview C#에서의 Call By Value C#에서의 Call By Reference 만약 ref키워드가 없는 자바같은 언어라면?</description>
    </item>
    
    <item>
      <title>[javascript] 꼬리 물기 최적화 (Tail Call Optimization)</title>
      <link>https://n4oah.github.io/posts/javascript/tail-call-optimization/</link>
      <pubDate>Wed, 24 Jun 2020 10:53:16 +0900</pubDate>
      
      <guid>https://n4oah.github.io/posts/javascript/tail-call-optimization/</guid>
      <description>꼬리 물기 최적화 (Tail Call Optimization) 함수 안에서 함수를 호출하면 호출이 된 함수에서 호출을 한 함수로 돌아오는 반환 지점을 가지고 있어야 한다.
Tail Call Optimization는 호출을 한 함수로 돌아오지 않아도 되도록 함수 설계하여 call stack메모리를 계속 재활용 할 수 있도록 하는 것 이다.
 최종적으로, 마지막 호출이 된 함수가 최초로 호출 된 함수로 반환
  조건  맨 마지막 구문에서 함수를 실행해야 함 언어 스팩상 호출을 한 함수의 stack에 메모리를 쌓지 않는 연산자는 사용 가능함   Tail Recursion 피보나치 수열 구하기 정확히 100번의 재귀호출로 피보나치 수열을 구하는 함수이다</description>
    </item>
    
  </channel>
</rss>
